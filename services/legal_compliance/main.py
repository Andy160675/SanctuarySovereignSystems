"""
Legal Compliance Actuator
=========================

Sector: legal
Capabilities: ['contract_review', 'policy_check', 'compliance_report_generation']

Auto-generated by actuator-gen. Implements the Sovereign System's
architectural principles: policy gating, ledger integration, and registry.
"""

import os
import asyncio
from datetime import datetime, timezone
from typing import Optional, Dict, Any

import httpx
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel


app = FastAPI(
    title="Legal Compliance Actuator",
    version="1.0.0"
)

# =============================================================================
# Configuration
# =============================================================================

ACTUATOR_NAME = "legal_compliance"
SECTOR = "legal"
PORT = 5011
CAPABILITIES = ['contract_review', 'policy_check', 'compliance_report_generation']

ACTUATOR_REGISTRY_URL = os.getenv("ACTUATOR_REGISTRY_URL", "http://actuator_registry:5100")
LEDGER_URL = os.getenv("LEDGER_URL", "http://ledger_service:8082")
EVIDENCE_URL = os.getenv("EVIDENCE_URL", "http://evidence_writer:8080/log")


# =============================================================================
# Models
# =============================================================================

class ExecuteRequest(BaseModel):
    mission_id: str
    mission_type: str
    details: Dict[str, Any] = {}
    context: Optional[Dict[str, Any]] = None


class ExecuteResponse(BaseModel):
    status: str  # "succeeded" | "failed" | "pending"
    mission_id: str
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


class HealthResponse(BaseModel):
    status: str
    actuator: str
    sector: str
    capabilities: list


# =============================================================================
# Registry Integration
# =============================================================================

async def register_with_registry():
    """Register this actuator with the central registry on startup."""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{ACTUATOR_REGISTRY_URL}/register",
                json={
                    "name": ACTUATOR_NAME,
                    "sector": SECTOR,
                    "capabilities": CAPABILITIES,
                    "endpoint": f"http://{ACTUATOR_NAME}:{PORT}",
                    "health_endpoint": f"http://{ACTUATOR_NAME}:{PORT}/health"
                }
            )
            if response.status_code in (200, 201):
                print(f"[{ACTUATOR_NAME}] Registered with actuator registry")
            else:
                print(f"[{ACTUATOR_NAME}] Registry registration returned: {response.status_code}")
    except Exception as e:
        print(f"[{ACTUATOR_NAME}] Failed to register with registry: {e}")


async def deregister_from_registry():
    """Deregister this actuator from the registry on shutdown."""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            await client.delete(f"{ACTUATOR_REGISTRY_URL}/deregister/{ACTUATOR_NAME}")
            print(f"[{ACTUATOR_NAME}] Deregistered from actuator registry")
    except Exception as e:
        print(f"[{ACTUATOR_NAME}] Failed to deregister: {e}")


# =============================================================================
# Ledger Integration
# =============================================================================

async def log_to_ledger(event_type: str, data: dict):
    """Write an event to the immutable ledger."""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            await client.post(
                f"{LEDGER_URL}/append",
                json={
                    "event_type": event_type,
                    "agent": ACTUATOR_NAME,
                    "action": data.get("action", event_type),
                    "target": data.get("mission_id", "unknown"),
                    "outcome": data.get("outcome", "unknown"),
                    "metadata": data
                }
            )
    except Exception as e:
        print(f"[{ACTUATOR_NAME}] Failed to log to ledger: {e}")


async def log_to_evidence(event_type: str, data: dict):
    """Log events to evidence writer."""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            await client.post(
                EVIDENCE_URL,
                json={
                    "event_type": event_type,
                    "agent": ACTUATOR_NAME,
                    "action": event_type,
                    "target": data.get("mission_id", "unknown"),
                    "outcome": data.get("status", "unknown"),
                    "jurisdiction": "UK",
                    "data": data
                }
            )
    except Exception as e:
        print(f"[{ACTUATOR_NAME}] Failed to log to evidence: {e}")


# =============================================================================
# Mission Execution Logic
# =============================================================================

async def execute_mission_logic(request: ExecuteRequest) -> ExecuteResponse:
    """
    Core mission execution logic.

    IMPLEMENT YOUR ACTUATOR'S CAPABILITIES HERE.

    This function should:
    1. Check request.mission_type against CAPABILITIES
    2. Execute the appropriate logic based on mission_type
    3. Return an ExecuteResponse with the result

    Example implementations for capabilities: ['contract_review', 'policy_check', 'compliance_report_generation']
    """

    # Validate mission type is in our capabilities
    if request.mission_type not in CAPABILITIES:
        return ExecuteResponse(
            status="failed",
            mission_id=request.mission_id,
            error=f"Unsupported mission type: {request.mission_type}. "
                  f"Supported: {CAPABILITIES}"
        )

    # =========================================================================
    # IMPLEMENT YOUR MISSION LOGIC BELOW
    # =========================================================================

    if request.mission_type == "contract_review":
        # Real implementation: scan contract text for high-risk clauses
        contract_text = request.details.get("contract_text", "").lower()
        document_name = request.details.get("document_name", "unknown_document")

        # Risk patterns to detect
        high_risk_patterns = [
            ("unlimited liability", "Unlimited liability clause detected"),
            ("indemnify and hold harmless", "Broad indemnification clause"),
            ("waive all rights", "Rights waiver clause"),
            ("perpetual license", "Perpetual license grant"),
            ("exclusive jurisdiction", "Exclusive jurisdiction clause"),
            ("automatic renewal", "Auto-renewal clause"),
            ("non-compete", "Non-compete restriction"),
        ]

        medium_risk_patterns = [
            ("termination for convenience", "Unilateral termination clause"),
            ("liquidated damages", "Liquidated damages clause"),
            ("limitation of liability", "Liability limitation clause"),
            ("confidentiality", "Confidentiality obligations"),
        ]

        findings = []
        risk_level = "LOW"

        for pattern, description in high_risk_patterns:
            if pattern in contract_text:
                findings.append({"risk": "HIGH", "clause": description, "pattern": pattern})
                risk_level = "HIGH"

        for pattern, description in medium_risk_patterns:
            if pattern in contract_text:
                findings.append({"risk": "MEDIUM", "clause": description, "pattern": pattern})
                if risk_level != "HIGH":
                    risk_level = "MEDIUM"

        result_data = {
            "capability": "contract_review",
            "document_name": document_name,
            "risk_level": risk_level,
            "findings_count": len(findings),
            "findings": findings,
            "recommendation": "Legal review required" if risk_level == "HIGH" else
                            "Review recommended" if risk_level == "MEDIUM" else
                            "Low risk - proceed with caution",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        return ExecuteResponse(
            status="succeeded",
            mission_id=request.mission_id,
            result=result_data
        )

    if request.mission_type == "policy_check":
        # TODO: Implement policy_check logic
        # Example:
        # input_data = request.details.get("input_field", "")
        # result = process_policy_check(input_data)
        result_data = {
            "capability": "policy_check",
            "status": "completed",
            "message": "policy_check executed successfully",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        return ExecuteResponse(
            status="succeeded",
            mission_id=request.mission_id,
            result=result_data
        )

    if request.mission_type == "compliance_report_generation":
        # TODO: Implement compliance_report_generation logic
        # Example:
        # input_data = request.details.get("input_field", "")
        # result = process_compliance_report_generation(input_data)
        result_data = {
            "capability": "compliance_report_generation",
            "status": "completed",
            "message": "compliance_report_generation executed successfully",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        return ExecuteResponse(
            status="succeeded",
            mission_id=request.mission_id,
            result=result_data
        )

    # Fallback - should not reach here if capabilities list is correct
    return ExecuteResponse(
        status="failed",
        mission_id=request.mission_id,
        error="No handler found for mission type"
    )


# =============================================================================
# API Endpoints
# =============================================================================

@app.get("/health", response_model=HealthResponse)
async def health():
    """Health check endpoint for registry and monitoring."""
    return HealthResponse(
        status="healthy",
        actuator=ACTUATOR_NAME,
        sector=SECTOR,
        capabilities=CAPABILITIES
    )


@app.get("/capabilities")
async def get_capabilities():
    """Return this actuator's capabilities."""
    return {
        "actuator": ACTUATOR_NAME,
        "sector": SECTOR,
        "capabilities": CAPABILITIES
    }


@app.post("/execute", response_model=ExecuteResponse)
async def execute_mission(request: ExecuteRequest):
    """
    Execute a mission dispatched by the orchestrator.

    This endpoint is called by the Mission Orchestrator when a workflow
    requires this actuator's capabilities.
    """
    print(f"[{ACTUATOR_NAME}] Executing mission {request.mission_id}: {request.mission_type}")

    # Log mission start
    await log_to_ledger("actuator_mission_start", {
        "mission_id": request.mission_id,
        "mission_type": request.mission_type,
        "actuator": ACTUATOR_NAME,
        "action": "mission_start",
        "outcome": "in_progress"
    })

    try:
        # Execute the mission
        response = await execute_mission_logic(request)

        # Log mission completion
        await log_to_ledger("actuator_mission_complete", {
            "mission_id": request.mission_id,
            "mission_type": request.mission_type,
            "actuator": ACTUATOR_NAME,
            "action": "mission_complete",
            "outcome": response.status,
            "result": response.result
        })

        # Log to evidence
        await log_to_evidence("mission_executed", {
            "mission_id": request.mission_id,
            "mission_type": request.mission_type,
            "status": response.status
        })

        print(f"[{ACTUATOR_NAME}] Mission {request.mission_id} completed: {response.status}")
        return response

    except Exception as e:
        error_msg = str(e)
        print(f"[{ACTUATOR_NAME}] Mission {request.mission_id} failed: {error_msg}")

        # Log failure
        await log_to_ledger("actuator_mission_failed", {
            "mission_id": request.mission_id,
            "mission_type": request.mission_type,
            "actuator": ACTUATOR_NAME,
            "action": "mission_failed",
            "outcome": "failed",
            "error": error_msg
        })

        return ExecuteResponse(
            status="failed",
            mission_id=request.mission_id,
            error=error_msg
        )


# =============================================================================
# Lifecycle Events
# =============================================================================

@app.on_event("startup")
async def startup_event():
    """Register with the actuator registry on startup."""
    print(f"[{ACTUATOR_NAME}] Starting up...")
    print(f"[{ACTUATOR_NAME}] Sector: {SECTOR}")
    print(f"[{ACTUATOR_NAME}] Capabilities: {CAPABILITIES}")

    # Give other services time to start
    await asyncio.sleep(2)
    await register_with_registry()

    print(f"[{ACTUATOR_NAME}] Ready to receive missions on port {PORT}")


@app.on_event("shutdown")
async def shutdown_event():
    """Deregister from the actuator registry on shutdown."""
    print(f"[{ACTUATOR_NAME}] Shutting down...")
    await deregister_from_registry()