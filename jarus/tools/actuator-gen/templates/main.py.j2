"""
{{ actuator_name | replace('_', ' ') | title }} Actuator
{{ '=' * (actuator_name | length + 9) }}

Sector: {{ sector }}
Capabilities: {{ capabilities }}

Auto-generated by actuator-gen. Implements the The Blade of Truth's
architectural principles: policy gating, ledger integration, and registry.
"""

import os
import asyncio
from datetime import datetime, timezone
from typing import Optional, Dict, Any

import httpx
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel


app = FastAPI(
    title="{{ actuator_name | replace('_', ' ') | title }} Actuator",
    version="1.0.0"
)

# =============================================================================
# Configuration
# =============================================================================

ACTUATOR_NAME = "{{ actuator_name }}"
SECTOR = "{{ sector }}"
PORT = {{ port }}
CAPABILITIES = {{ capabilities }}

ACTUATOR_REGISTRY_URL = os.getenv("ACTUATOR_REGISTRY_URL", "http://actuator_registry:5100")
LEDGER_URL = os.getenv("LEDGER_URL", "http://ledger_service:8082")
EVIDENCE_URL = os.getenv("EVIDENCE_URL", "http://evidence_writer:8080/log")


# =============================================================================
# Models
# =============================================================================

class ExecuteRequest(BaseModel):
    mission_id: str
    mission_type: str
    details: Dict[str, Any] = {}
    context: Optional[Dict[str, Any]] = None


class ExecuteResponse(BaseModel):
    status: str  # "succeeded" | "failed" | "pending"
    mission_id: str
    result: Optional[Dict[str, Any]] = None
    error: Optional[str] = None


class HealthResponse(BaseModel):
    status: str
    actuator: str
    sector: str
    capabilities: list


# =============================================================================
# Registry Integration
# =============================================================================

async def register_with_registry():
    """Register this actuator with the central registry on startup."""
    try:
        async with httpx.AsyncClient(timeout=10.0) as client:
            response = await client.post(
                f"{ACTUATOR_REGISTRY_URL}/register",
                json={
                    "name": ACTUATOR_NAME,
                    "sector": SECTOR,
                    "capabilities": CAPABILITIES,
                    "endpoint": f"http://{ACTUATOR_NAME}:{PORT}",
                    "health_endpoint": f"http://{ACTUATOR_NAME}:{PORT}/health"
                }
            )
            if response.status_code in (200, 201):
                print(f"[{ACTUATOR_NAME}] Registered with actuator registry")
            else:
                print(f"[{ACTUATOR_NAME}] Registry registration returned: {response.status_code}")
    except Exception as e:
        print(f"[{ACTUATOR_NAME}] Failed to register with registry: {e}")


async def deregister_from_registry():
    """Deregister this actuator from the registry on shutdown."""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            await client.delete(f"{ACTUATOR_REGISTRY_URL}/deregister/{ACTUATOR_NAME}")
            print(f"[{ACTUATOR_NAME}] Deregistered from actuator registry")
    except Exception as e:
        print(f"[{ACTUATOR_NAME}] Failed to deregister: {e}")


# =============================================================================
# Ledger Integration
# =============================================================================

async def log_to_ledger(event_type: str, data: dict):
    """Write an event to the immutable ledger."""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            await client.post(
                f"{LEDGER_URL}/append",
                json={
                    "event_type": event_type,
                    "agent": ACTUATOR_NAME,
                    "action": data.get("action", event_type),
                    "target": data.get("mission_id", "unknown"),
                    "outcome": data.get("outcome", "unknown"),
                    "metadata": data
                }
            )
    except Exception as e:
        print(f"[{ACTUATOR_NAME}] Failed to log to ledger: {e}")


async def log_to_evidence(event_type: str, data: dict):
    """Log events to evidence writer."""
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            await client.post(
                EVIDENCE_URL,
                json={
                    "event_type": event_type,
                    "agent": ACTUATOR_NAME,
                    "action": event_type,
                    "target": data.get("mission_id", "unknown"),
                    "outcome": data.get("status", "unknown"),
                    "jurisdiction": "UK",
                    "data": data
                }
            )
    except Exception as e:
        print(f"[{ACTUATOR_NAME}] Failed to log to evidence: {e}")


# =============================================================================
# Mission Execution Logic
# =============================================================================

async def execute_mission_logic(request: ExecuteRequest) -> ExecuteResponse:
    """
    Core mission execution logic.

    IMPLEMENT YOUR ACTUATOR'S CAPABILITIES HERE.

    This function should:
    1. Check request.mission_type against CAPABILITIES
    2. Execute the appropriate logic based on mission_type
    3. Return an ExecuteResponse with the result

    Example implementations for capabilities: {{ capabilities }}
    """

    # Validate mission type is in our capabilities
    if request.mission_type not in CAPABILITIES:
        return ExecuteResponse(
            status="failed",
            mission_id=request.mission_id,
            error=f"Unsupported mission type: {request.mission_type}. "
                  f"Supported: {CAPABILITIES}"
        )

    # =========================================================================
    # IMPLEMENT YOUR MISSION LOGIC BELOW
    # =========================================================================
{% for capability in capabilities %}

    if request.mission_type == "{{ capability }}":
        # TODO: Implement {{ capability }} logic
        # Example:
        # input_data = request.details.get("input_field", "")
        # result = process_{{ capability }}(input_data)
        result_data = {
            "capability": "{{ capability }}",
            "status": "completed",
            "message": "{{ capability }} executed successfully",
            "timestamp": datetime.now(timezone.utc).isoformat()
        }
        return ExecuteResponse(
            status="succeeded",
            mission_id=request.mission_id,
            result=result_data
        )
{% endfor %}

    # Fallback - should not reach here if capabilities list is correct
    return ExecuteResponse(
        status="failed",
        mission_id=request.mission_id,
        error="No handler found for mission type"
    )


# =============================================================================
# API Endpoints
# =============================================================================

@app.get("/health", response_model=HealthResponse)
async def health():
    """Health check endpoint for registry and monitoring."""
    return HealthResponse(
        status="healthy",
        actuator=ACTUATOR_NAME,
        sector=SECTOR,
        capabilities=CAPABILITIES
    )


@app.get("/capabilities")
async def get_capabilities():
    """Return this actuator's capabilities."""
    return {
        "actuator": ACTUATOR_NAME,
        "sector": SECTOR,
        "capabilities": CAPABILITIES
    }


@app.post("/execute", response_model=ExecuteResponse)
async def execute_mission(request: ExecuteRequest):
    """
    Execute a mission dispatched by the orchestrator.

    This endpoint is called by the Mission Orchestrator when a workflow
    requires this actuator's capabilities.
    """
    print(f"[{ACTUATOR_NAME}] Executing mission {request.mission_id}: {request.mission_type}")

    # Log mission start
    await log_to_ledger("actuator_mission_start", {
        "mission_id": request.mission_id,
        "mission_type": request.mission_type,
        "actuator": ACTUATOR_NAME,
        "action": "mission_start",
        "outcome": "in_progress"
    })

    try:
        # Execute the mission
        response = await execute_mission_logic(request)

        # Log mission completion
        await log_to_ledger("actuator_mission_complete", {
            "mission_id": request.mission_id,
            "mission_type": request.mission_type,
            "actuator": ACTUATOR_NAME,
            "action": "mission_complete",
            "outcome": response.status,
            "result": response.result
        })

        # Log to evidence
        await log_to_evidence("mission_executed", {
            "mission_id": request.mission_id,
            "mission_type": request.mission_type,
            "status": response.status
        })

        print(f"[{ACTUATOR_NAME}] Mission {request.mission_id} completed: {response.status}")
        return response

    except Exception as e:
        error_msg = str(e)
        print(f"[{ACTUATOR_NAME}] Mission {request.mission_id} failed: {error_msg}")

        # Log failure
        await log_to_ledger("actuator_mission_failed", {
            "mission_id": request.mission_id,
            "mission_type": request.mission_type,
            "actuator": ACTUATOR_NAME,
            "action": "mission_failed",
            "outcome": "failed",
            "error": error_msg
        })

        return ExecuteResponse(
            status="failed",
            mission_id=request.mission_id,
            error=error_msg
        )


# =============================================================================
# Lifecycle Events
# =============================================================================

@app.on_event("startup")
async def startup_event():
    """Register with the actuator registry on startup."""
    print(f"[{ACTUATOR_NAME}] Starting up...")
    print(f"[{ACTUATOR_NAME}] Sector: {SECTOR}")
    print(f"[{ACTUATOR_NAME}] Capabilities: {CAPABILITIES}")

    # Give other services time to start
    await asyncio.sleep(2)
    await register_with_registry()

    print(f"[{ACTUATOR_NAME}] Ready to receive missions on port {PORT}")


@app.on_event("shutdown")
async def shutdown_event():
    """Deregister from the actuator registry on shutdown."""
    print(f"[{ACTUATOR_NAME}] Shutting down...")
    await deregister_from_registry()

